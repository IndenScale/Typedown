# 演变语义 (Evolution)

Typedown 不将数据视为静态产物，而是一个不断进化的时间线。

## 1. 线性演变 (`former`)

`former` 关键字将一个新实体状态链接到其上一个版本。

- **语法**: 在实体主体中使用 `former: "QueryString"`。
- **约束**: **必须使用全局寻址 (Global Addressing)**。
  - 🚫 **禁止**: 局部 Handle (如 `alice`)。演变关系必须跨越文件和上下文保持稳定。
  - ✅ **允许**:
    - **Slug ID**: `users/alice-v1` (最常用)
    - **UUID**: `550e84...` (机器生成的唯一标识)
    - **Block Fingerprint**: `sha256:8f4b...` (基于内容的哈希，最精确)
- **语义**:
  - **身份一致性**: 新实体在逻辑上代表同一个对象的不同时间点。
  - **合并策略**: 编译器执行**深度合并**。新块中出现的字段覆盖旧字段，未出现的字段从 `former` 实体继承。
  - **不可变性**: 旧 ID 依然是一个有效的、不可变的快照。

示例

````markdown
## 版本 1

```entity:Feature id=login_v1
status: planned
```

## 版本 2

```entity:Feature id=login_v2
former: "login_v1"
status: in_progress
```
````

## 2. 结构派生 (`derived_from`)

`derived_from` 关键字实现基于原型的继承。

- **语法**: `derived_from: "QueryString"`。
- **约束**: 同 `former`，**必须使用全局寻址** (Slug ID, UUID, Hash)。
- **语义**:
  - **身份独立性**: 新实体是一个**不同**的逻辑对象，但共享父实体的结构和数据。
  - **继承**: 类似于类继承。子实体以父实体的副本为起点并应用覆盖。

示例

````yaml
```entity:Enemy id=小怪
hp: 50
```

```entity:Enemy id=强化小怪
derived_from: "小怪"
hp: 100
```

````

## 3. 确定性合并策略 (Deterministic Merging)

为了消除歧义，Typedown 定义了严格的合并行为。这适用于 `former` 和 `derived_from`。

### 3.1 对象 (Objects): 递归合并 (Recursive)

对于字典/对象类型的字段，执行 Key 级别的递归合并。

- **Existing Keys**: 子类的值覆盖父类的值。
- **New Keys**: 子类的新增 Key 被合并进去。
- **Missing Keys**: 父类中存在但子类未定义的 Key，保持原样（继承）。

### 3.2 列表 (Lists): 原子替换 (Atomic Replace)

对于列表/数组类型的字段，执行**完全替换**。

> **规则**: `Child.list_field` 如果存在，则完全取代 `Parent.list_field`。即便子类列表为空 `[]`，也会清空父类列表。

- **理由**: 列表通常是有序的集合。如果默认为 Append，会导致顺序不可控以及“无法删除元素”的问题。
- **扩展方式**: 如果需要“追加”，必须显式地将父类元素包含在子类列表中。

### 3.3 空值 (Nulls): 显式赋值 (Explicit Assignment)

- **语义**: `key: null` 表示将该字段的值显式设置为 `None`（前提是 Schema 允许 Optional）。
- **非删除**: 它**不**等同于“删除该 Key 让其回退到 Default Value”。在 Typedown 的合并语义中，Null 是一个有效的一等公民值，用于覆盖父类的非空值。

## 4. 源码形态与物化 (Source vs. Materialized)

基于上述合并策略，Typedown 确立了推荐的源码书写形态：

- **增量书写 (Delta Writing)**: 源码应仅包含与父级 (`former`/`derived_from`) 的**差异部分**。
  - ✅ **推荐**: 只写变化的字段。
  - ❌ **不推荐**: 在源码中手动复制父类的所有字段（除非为了文档的可读性显式展示）。
- **工具侧物化 (Tooling Materialization)**:
  - 所谓的“完整数据”应由编译器或 LSP 实时计算并在**内存**中呈现。
  - **不要**将计算结果反写回源码文件，这会切断未来的继承更新链路，并破坏 "Single Source of Truth"。

---

## 散敛规则

- **演变分叉 (错误)**: 一个 ID 不能成为两个不同实体的 `former`。时间线不可分裂。
- **派生分叉 (允许)**: 一个 ID 可以被多个实体 `derived_from`。
