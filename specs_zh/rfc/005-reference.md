# 实体引用与链接 (Reference)

Typedown 通过 `[[]]` 语法支持强大的实体引用功能，这是构建关联性文档网络的核心。它将引用视为一种 **`query`** (查询)。

## 基础引用语法 (`[[query]]`)

使用双中括号 `[[query]]` 来引用其他 Entity。这个 `query` 可以是一个 ID、名称、或更复杂的条件表达式。
这不仅是一个超链接，更是一个语义上的**强关联**。编译器会验证 `query` 的有效性。

- **引用 Entity**: `[[查询条件]]`
- **引用 Entity 字段**: `[[查询条件.字段名]]`

```markdown
# 示例引用

这里引用了管理员 [[Alice]]。
管理员 [[Alice]].name 的名字是 [[Alice.name]]。
```

## 引用解析机制

### 1. 模糊匹配 (Fuzzy Matching)

Typedown 强大的引用解析引擎支持模糊匹配。当 `[[query]]` 不完全精确时，编译器和 LSP 会尝试在符号表中搜索最可能的匹配项。

- **ID 模糊匹配**: `[[feat_login]]` 可以匹配 `feat_login_v3`。
- **名称模糊匹配**: `[[Alice]]` 可以匹配 `id: u_001` 且 `name: "Alice"` 的 Entity。
- **字段模糊匹配**: `[[hero.hp]]` 可以智能匹配 `hero` Entity 的 `hit_points` 字段，如果存在别名或模糊匹配设置。

这种机制极大地方便了编写者，减少了硬编码 ID 的需求。

### 2. 歧义检查与报告 (Ambiguity Check)

由于模糊匹配的存在，一个 `[[query]]` 可能匹配到零个、一个或多个实体。

- **零匹配**: 编译器报告 `ReferenceNotFound` 错误。
- **多匹配**: 编译器报告 `AmbiguousReferenceError` 错误。
  - LSP 插件会在编辑器中实时显示波浪线和错误提示，指导用户修正 `query`。
  - `extension` 和 `compiler` 会协同工作，确保所有引用都具有唯一且明确的解析路径。

## 引用指向的版本策略

在使用了 `former` 机制的演变链条中，对同一个概念的引用（例如 `[[feat_login]]`）可能对应多个历史版本。
**默认行为：编译时解析为最新版本 (Resolve to Latest)**

- 当一个 `[[query]]` 匹配到某个实体家族的多个版本时，Typedown 编译器会默认解析到该实体家族链条的**最新版本 (Tip of the Chain)**。
- **优点**:
  - **语义一致性**: 确保文档的验证逻辑始终基于最新的事实。如果文档中的逻辑因最新数据而变得不一致，这通常意味着文档本身需要更新或 `spec` 需要调整，从而促进了“渐进式形式化”。
  - **简化编写**: 作者无需手动更新所有引用来指向最新的 `_v3`, `_v4`。
- **缺点**:
  - 历史文档在阅读时，如果未锁定版本，其引用内容会随最新版本而变化。

### 显式引用特定版本

如果确实需要引用历史上的某个特定快照，必须使用能够唯一识别该版本的 `query`。

- `[[feat_login_v1]]`: 明确指向 V1 版本。
- `[[User where id="u_001_v2"]]`: 使用更精确的查询条件。

## 复杂引用维护

随着项目规模扩大，引用关系会变得复杂。Typedown 建议并支持以下维护策略：

### 版本后缀命名约定

建议使用 `_v<版本号>` 的后缀格式来管理 Entity ID 的演变，以提升可读性和可追踪性。

- `u_001_v1`
- `u_001_v2`
- `u_001_v2.1`

### 历史查询与重构

IDE 插件应支持 `Find All References` (查找所有引用) 和 `Rename Symbol` (重命名符号)。
当 Entity ID 发生变化（例如修正拼写）时，工具链应能通过 LSP 自动更新所有指向该 Entity 的 `[[query]]` 引用，尽量保持语义上的不变性。
