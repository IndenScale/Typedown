# 核心理念 (Core Concepts)

Typedown 不仅仅是为 Markdown 添加数据支持，更是一套关于**模型演进**的方法论。在设计过程中，我们做出了几个关键的权衡（Trade-offs），本篇文档将解释这些设计背后的“为什么”。

## 1. 为什么“引用即查询”？ (Why Reference as Query)

在传统的编程语言或配置中，引用通常是一个**地址 (Address)**，例如文件路径 `../db/config.json` 或内存指针。

Typedown 选择将 `[[...]]` 视为一个**查询意图 (Query Intent)**。

- **解耦 (Decoupling)**: 当你写下 `[[db]]` 时，你表达的是“我需要那个叫做 db 的东西”，而不是“去加载路径 X 的文件”。
- **迟绑定 (Late Binding)**: 具体的解析逻辑被推迟到了运行时。这意味着同一个 `app.td` 文件，放在 `prod/` 目录下时 `[[db]]` 指向生产库，放在 `dev/` 目录下时指向测试库。
- **环境多态 (Environmental Polymorphism)**: 这是实现“一份代码，多处运行”的基石。

## 2. 为什么禁止多层列表？ (Why No Nested Lists)

Typedown 在设计上**严禁**在 Entity Body 中使用二维数组（List of Lists）。

**原因：为了“智能解包 (Smart Unboxing)”的语法糖。**

我们需要支持以下直觉性的写法：

```yaml
# 写法 A: 单个引用
manager: [[alice]] # 编译器自动包装为 List<Reference>

# 写法 B: 列表引用
team:
  - [[bob]]
  - [[charlie]]
```

在标准 YAML 中，`[[alice]]` 实质上是一个嵌套列表 `[["alice"]]`。
如果允许用户定义真实的嵌套列表，编译器将无法区分 `[[alice]]` 到底是一个“包含字符串 alice 的列表”，还是一个“指向 alice 的引用”。

为了消除这种歧义（Ambiguity），并保留极致简洁的引用语法，我们必须在数据结构层面做出限制。**如果你需要矩阵数据，请定义一个专门的 Model 结构来封装它，而不是直接使用原生 List。**

## 3. 为什么使用隐式上下文？ (Why Implicit Context)

在 Python 或 TS 中，我们习惯显式 `import`。但在数据密集型的场景下，显式导入会带来巨大的噪音。

Typedown 采用**文件系统即模块 (Filesystem as Module)** 的理念。

- **约定优于配置**: 文件的物理位置决定了它的逻辑作用域。子目录自动继承父目录的配置。
- **可移动性**: 将文件从文件夹 A 移动到 文件夹 B，它会自动获得新环境的 Context，而无需修改文件内部的代码。这对于大规模知识库的重构至关重要。

这种设计使得数据文件本身保持纯净，将复杂的依赖关系管理交给文件系统结构来表达。
